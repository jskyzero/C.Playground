# Linux  POSIX线程互斥和同步

## HelloWorld
这就必须要使用上次的进程相关的知识了，上锁机制的目的也就是为了进程间的同步，说简单点就是只能有一个进程访问关键区。

样例很通俗，不管是创建使用进程部分还是使用mutex部分，基本思路就是上锁解锁，要记得在一开始要初始化最后要摧毁。

因为简单，自然没有包括mutex的三种类型和两种初始化方法。

## semaphore
信号量还是很有意思的，使用的方法和mutex套路是一样的，不同在于这里可以指定一个初始值，不过例程改为纯C语言描述后在mac OS 下是会报启用警告的，具体可以参考这个[问题](https://stackoverflow.com/questions/27736618/why-are-sem-init-sem-getvalue-sem-destroy-deprecated-on-mac-os-x-and-w)，最开始还想蒙混过关，最后还是不行，所以最后的编写环境是`Ubuntu 16.04LTS`
不过还是有点疑惑，双值和计数型信号量是怎么区分的，后看看到了参考如下
```
#include <semaphore.h>

int sem_init( sem_t * sem, 
              int pshared, 
              unsigned value );
value
The initial value of the semaphore. A positive value (i.e., greater than zero) indicates an unlocked semaphore, and a value of 0 (zero) indicates a locked semaphore. This value must not exceed SEM_VALUE_MAX.
```
嗯这就好办了。

## 生产者消费者问题
> 设计一个程序来解决有限缓冲问题，其中的生产者与消费者进程如图6.10 与图6.11 所示。
> 在6.6.1 小节中，使用了三个信号量: empty (以记录有多少空位)、full (以记录有多少满位)以及mutex (二进制信号量或互斥信号量，以保护对缓冲插入与删除的操作)。对于本项目， empty 与full 将采用标准计数信号量，而mutex 将采用二进制信号量。生产者与消费者作为独立线程，在empty、full、mutex 的同步前提下，对缓冲进行插入与删除。
> 本项目，可采用Pthread 。

嗯，思路大概是先写出文件读写框架，然后加入创建线程部分，最后加入信号量部分，具体的代码和输出请参考3.1部分，因为书上本来就有算法所以写起来也没费太大功夫。

## 读者写者问题
>  实验要求
>  在Linux环境下，创建一个进程，此进程包含n个线程。用这n个线程来表示n个读者或写者。每个线程按相应测试数据文件(后面有介绍)的要求进行读写操作。用信号量机制分别实现读者优先和写者优先的读者-写者问题。
>  读者-写者问题的读写操作限制(仅读者优先或写者优先)：
>  1)写-写互斥，即不能有两个写者同时进行写操作。
>  2)读-写互斥，即不能同时有一个线程在读，而另一个线程在写。
>  3)读-读允许，即可以有一个或多个读者在读。
>  读者优先的附加限制：如果一个读者申请进行读操作时已有另一个读者正在进行读操作，则该读者可直接开始读操作。
>  写者优先的附加限制：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态后才能开始读操作。
>  运行结果显示要求：要求在每个线程创建、发出读写操作申请、开始读写操作和结束读写操作时分别显示一行提示信息，以确定所有处理都遵守相应的读写操作限制。

有了上面一次的经验，这次写的就很轻松，读者优先书上是给出算法了的，所以对着翻译就好了，写者优先参考了网上的算法，用的锁有点多，具体请参考3.2对应文件部分。

## 心得体会

进程通信比想象中有意思，不过目前的所有程序都是数据以全局变量共享，如果以后有机会想试一下真正意义上的共享存储空间，另外就是踩了很多坑，主要是关于环境的问题，之前一直是在mac OS下进行C编程，现在重新装了Linux虚拟机倒也还行。

## REFERENCE
[POSIX Threads Programming](https://computing.llnl.gov/tutorials/pthreads/)